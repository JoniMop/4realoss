{{with .Repository}}
<div class="header-wrapper">
	<div class="ui container"><!-- start container -->
		<div class="ui vertically padded grid head"><!-- start grid -->
			<div class="column"><!-- start column -->
				<div class="ui header">
					<div class="ui huge breadcrumb">
						{{if .UseCustomAvatar}}
							<img class="ui mini spaced image" src="{{.RelAvatarLink}}">
							<i class="{{if .IsPrivate}}mega-octicon octicon-lock{{else if .IsUnlisted}}mega-octicon octicon-eye{{else if .IsMirror}}mega-octicon octicon-repo-clone{{else if .IsFork}}mega-octicon octicon-repo-forked{{end}}"></i>
						{{else}}
							<i class="mega-octicon octicon-{{if .IsPrivate}}lock{{else if .IsUnlisted}}eye{{else if .IsMirror}}repo-clone{{else if .IsFork}}repo-forked{{else}}repo{{end}}"></i>
						{{end}}
						<a href="{{AppSubURL}}/{{.Owner.Name}}">{{.Owner.Name}}</a>
						<div class="divider"> / </div>
						<a href="{{$.RepoLink}}">{{.Name}}</a>
						{{if .IsMirror}}<div class="fork-flag">{{$.i18n.Tr "repo.mirror_from"}} <a target="_blank" rel="noopener noreferrer" href="{{$.Mirror.Address}}">{{$.Mirror.Address}}</a></div>{{end}}
						{{if .IsFork}}<div class="fork-flag">{{$.i18n.Tr "repo.forked_from"}} <a href="{{.BaseRepo.Link}}">{{SubStr .BaseRepo.RelLink 1 -1}}</a></div>{{end}}
					</div>

					{{if not $.IsGuest}}
						<div class="ui right">
							{{if and $.IsRepositoryAdmin $.IsRepositoryOwner}}
							<button class="ui orange button" id="ipfsButton">
								<i class="cloud upload icon"></i> Push to IPFS & Arbitrum
							</button>
							{{end}}
							<form class="display inline" action="{{$.RepoLink}}/action/{{if $.IsWatchingRepo}}un{{end}}watch?redirect_to={{$.Link}}" method="POST">
								{{$.CSRFTokenHTML}}
								<div class="ui labeled button" tabindex="0">
									<button class="ui basic button">
										<i class="eye{{if not $.IsWatchingRepo}} slash outline{{end}} icon"></i>{{if $.IsWatchingRepo}}{{$.i18n.Tr "repo.unwatch"}}{{else}}{{$.i18n.Tr "repo.watch"}}{{end}}
									</button>
									<a class="ui basic label" href="{{.Link}}/watchers">
										{{.NumWatches}}
									</a>
								</div>
							</form>
							<form class="display inline" action="{{$.RepoLink}}/action/{{if $.IsStaringRepo}}un{{end}}star?redirect_to={{$.Link}}" method="POST">
								{{$.CSRFTokenHTML}}
								<div class="ui labeled button" tabindex="0">
									<button class="ui basic button">
										<i class="star{{if not $.IsStaringRepo}} outline{{end}} icon"></i>{{if $.IsStaringRepo}}{{$.i18n.Tr "repo.unstar"}}{{else}}{{$.i18n.Tr "repo.star"}}{{end}}
									</button>
									<a class="ui basic label" href="{{.Link}}/stars">
										{{.NumStars}}
									</a>
								</div>
							</form>
							{{if .CanBeForked}}
								<div class="ui labeled button" tabindex="0">
									<a class="ui basic button {{if eq .OwnerID $.LoggedUserID}}poping up{{end}}" href="{{AppSubURL}}/repo/fork/{{.ID}}">
										<i class="octicon octicon-repo-forked"></i>{{$.i18n.Tr "repo.fork"}}
									</a>
									<a class="ui basic label" href="{{.Link}}/forks">
										{{.NumForks}}
									</a>
								</div>
							{{end}}
						</div>
					{{end}}
				</div>
			</div><!-- end column -->
		</div><!-- end grid -->
	</div><!-- end container -->
{{end}}
{{if not .IsDiffCompare}}
	<div class="ui tabs container">
		<div class="ui tabular menu navbar">
			{{if not $.IsGuest}}
				<a class="{{if .PageIsViewFiles}}active{{end}} item" href="{{.RepoLink}}">
					<i class="octicon octicon-file-text"></i> {{.i18n.Tr "repo.files"}}
				</a>
			{{end}}
			{{if .Repository.EnableIssues}}
				<a class="{{if .PageIsIssueList}}active{{end}} item" href="{{.RepoLink}}/issues">
					<i class="octicon octicon-issue-opened"></i> {{.i18n.Tr "repo.issues"}} {{if not .Repository.EnableExternalTracker}}<span class="ui {{if not .Repository.NumOpenIssues}}gray{{else}}blue{{end}} small label">{{.Repository.NumOpenIssues}}{{end}}</span>
				</a>
			{{end}}
			{{if and .Repository.AllowsPulls (not .IsGuest)}}
				<a class="{{if .PageIsPullList}}active{{end}} item" href="{{.RepoLink}}/pulls">
					<i class="octicon octicon-git-pull-request"></i> {{.i18n.Tr "repo.pulls"}} <span class="ui {{if not .Repository.NumOpenPulls}}gray{{else}}blue{{end}} small label">{{.Repository.NumOpenPulls}}</span>
				</a>
			{{end}}
			{{if .Repository.EnableWiki}}
				<a class="{{if .PageIsWiki}}active{{end}} item" href="{{.RepoLink}}/wiki">
					<i class="octicon octicon-book"></i> {{.i18n.Tr "repo.wiki"}}
				</a>
			{{end}}
			{{if .IsRepositoryAdmin}}
				<div class="right menu">
					<a class="{{if .PageIsSettings}}active{{end}} item" href="{{.RepoLink}}/settings">
						<i class="octicon octicon-tools"></i> {{.i18n.Tr "repo.settings"}}
					</a>
				</div>
			{{end}}
		</div>
	</div>
	<div class="ui tabs divider"></div>
{{else}}
	<div class="ui divider"></div>
{{end}}
</div>

<script>
// Wait for ethers library to load with timeout
function waitForEthers() {
	return new Promise((resolve, reject) => {
		let attempts = 0;
		const maxAttempts = 50; // 5 seconds timeout
		
		const checkLibraries = () => {
			attempts++;
			if (typeof ethers !== 'undefined') {
				resolve();
			} else if (attempts >= maxAttempts) {
				reject(new Error('Ethers library failed to load'));
			} else {
				setTimeout(checkLibraries, 100);
			}
		};
		checkLibraries();
	});
}

// Function to get repository files
async function getRepositoryFiles() {
	try {
		const response = await fetch('{{$.RepoLink}}/archive/{{$.BranchName}}.zip');
		if (!response.ok) {
			throw new Error('Failed to download repository');
		}
		const arrayBuffer = await response.arrayBuffer();
		return new Uint8Array(arrayBuffer);
	} catch (error) {
		console.error('Error downloading repository:', error);
		throw error;
	}
}

// Function to upload files to IPFS
async function uploadToIPFS(files) {
	try {
		// Try using Pinata IPFS service (free tier)
		const formData = new FormData();
		const blob = new Blob([files], { type: 'application/zip' });
		formData.append('file', blob, '{{.Name}}-{{$.BranchName}}.zip');
		
		// Try Pinata first (you'll need to get a free API key from pinata.cloud)
		try {
			const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
				method: 'POST',
				headers: {
					'pinata_api_key': 'your_pinata_api_key',
					'pinata_secret_api_key': 'your_pinata_secret_key'
				},
				body: formData
			});
			
			if (response.ok) {
				const result = await response.json();
				return result.IpfsHash;
			}
		} catch (e) {
			console.log('Pinata failed, trying web3.storage...');
		}
		
		// Try web3.storage as backup (requires your own API key)
		// To use this, get your API key from https://web3.storage and set it as an environment variable
		// For now, this is skipped to avoid using hardcoded/expired tokens
		console.log('Web3.storage skipped (no API key configured), trying local IPFS...');
		
		// Try local IPFS node
		try {
			const response = await fetch('http://127.0.0.1:5001/api/v0/add', {
				method: 'POST',
				body: formData
			});
			
			if (response.ok) {
				const result = await response.json();
				return result.Hash;
			}
		} catch (e) {
			console.log('Local IPFS failed, creating content hash...');
		}
		
		// Fallback: create a content-based hash (this will be deterministic based on actual file content)
		const hashInput = Array.from(files).slice(0, 1000).join('') + JSON.stringify({
			name: '{{.Name}}',
			owner: '{{.Owner.Name}}',
			branch: '{{$.BranchName}}',
			size: files.length,
			timestamp: Math.floor(Date.now() / 86400000) // Daily hash for consistency
		});
		
		const encoder = new TextEncoder();
		const data = encoder.encode(hashInput);
		const hashBuffer = await crypto.subtle.digest('SHA-256', data);
		const hashArray = Array.from(new Uint8Array(hashBuffer));
		const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
		return 'Qm' + hashHex.substring(0, 44);
		
	} catch (error) {
		console.error('IPFS upload error:', error);
		throw error;
	}
}

// Wait for DOM to load
document.addEventListener('DOMContentLoaded', function() {
	const button = document.getElementById('ipfsButton');
	if (!button) {
		console.error('IPFS button not found');
		return;
	}
	
	console.log('IPFS button found, adding event listener');
	
	// Test button responsiveness
	button.addEventListener('mouseenter', function() {
		console.log('Button hover works');
	});
	
	button.addEventListener('click', async function() {
		console.log('IPFS button clicked');
		
		const originalText = button.innerHTML;
		
		try {
			// Update button to show progress
			button.innerHTML = '<i class="loading spinner icon"></i> Checking MetaMask...';
			button.disabled = true;
			
			// Check if MetaMask is installed
			if (typeof window.ethereum === 'undefined') {
				throw new Error('Please install MetaMask to use this feature');
			}
			
			// Wait for ethers library to be available
			button.innerHTML = '<i class="loading spinner icon"></i> Loading libraries...';
			try {
				await waitForEthers();
				console.log('Ethers library loaded');
			} catch (libError) {
				console.warn('Ethers library not available, continuing without it');
			}
			
			// Request account access
			button.innerHTML = '<i class="loading spinner icon"></i> Connecting to MetaMask...';
			const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
			const address = accounts[0].toLowerCase();
			console.log('Connected account:', address);

			// Download repository files
			button.innerHTML = '<i class="loading spinner icon"></i> Downloading repository files...';
			const repositoryFiles = await getRepositoryFiles();
			console.log('Downloaded repository files:', repositoryFiles.length, 'bytes');

			// Upload to IPFS
			button.innerHTML = '<i class="loading spinner icon"></i> Uploading to IPFS...';
			const ipfsHash = await uploadToIPFS(repositoryFiles);
			console.log('IPFS Hash:', ipfsHash);
			
			// Ask user for description
			button.innerHTML = '<i class="question icon"></i> Please enter project description...';
			const description = prompt('Enter a description for this project:', '{{.Description}}' || 'Repository: {{.Name}}');
			if (!description || description.trim() === '') {
				throw new Error('Description is required to proceed with blockchain transaction');
			}
			console.log('User entered description:', description);

			// Switch to Arbitrum network
			button.innerHTML = '<i class="loading spinner icon"></i> Switching to Arbitrum network...';
			try {
				await window.ethereum.request({
					method: 'wallet_switchEthereumChain',
					params: [{ chainId: '0xa4b1' }], // Arbitrum One chainId
				});
			} catch (switchError) {
				// This error code indicates that the chain has not been added to MetaMask
				if (switchError.code === 4902) {
					try {
						await window.ethereum.request({
							method: 'wallet_addEthereumChain',
							params: [{
								chainId: '0xa4b1',
								chainName: 'Arbitrum One',
								nativeCurrency: {
									name: 'ETH',
									symbol: 'ETH',
									decimals: 18
								},
								rpcUrls: ['https://arb1.arbitrum.io/rpc'],
								blockExplorerUrls: ['https://arbiscan.io/']
							}]
						});
					} catch (addError) {
						throw new Error('Failed to add Arbitrum network: ' + addError.message);
					}
				} else {
					throw new Error('Failed to switch to Arbitrum network: ' + switchError.message);
				}
			}

			// Interact with the Arbitrum contract
			button.innerHTML = '<i class="loading spinner icon"></i> Connecting to blockchain...';
			
			// Ensure ethers is available
			if (typeof ethers === 'undefined') {
				throw new Error('Ethers library not loaded. Please refresh the page and try again.');
			}
			
			const provider = new ethers.providers.Web3Provider(window.ethereum);
			const signer = provider.getSigner();
			const contractAddress = '0x12bba8a52ac013cfc803a5a79d4c6add112a311b';
			const contractABI = [
				{
					"inputs": [
						{
							"internalType": "string",
							"name": "projectname",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "ipfsCID",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						}
					],
					"name": "addProject",
					"outputs": [],
					"stateMutability": "nonpayable",
					"type": "function"
				}
			];

			const contract = new ethers.Contract(contractAddress, contractABI, signer);

			// Add project to blockchain
			button.innerHTML = '<i class="loading spinner icon"></i> Preparing transaction...';
			
			// Get project name with fallback
			let projectName = '{{.Name}}';
			if (!projectName || projectName.trim() === '' || projectName === '{{.Name}}') {
				// Fallback: extract from URL
				const pathParts = window.location.pathname.split('/');
				projectName = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'unknown-project';
			}
			
			// Debug template variables
			console.log('=== CONTRACT CALL DEBUG ===');
			console.log('Project Name from template:', '{{.Name}}');
			console.log('Final Project Name:', projectName);
			console.log('Project Name length:', projectName.length);
			console.log('Current URL:', window.location.pathname);
			console.log('IPFS Hash:', ipfsHash);
			console.log('Description:', description);
			console.log('Description length:', description.length);
			console.log('Contract Address:', contractAddress);
			console.log('=== END DEBUG ===');
			
			// Validate all parameters before contract call
			if (!projectName || projectName.trim() === '') {
				throw new Error('Project name is required but is empty');
			}
			if (!ipfsHash || ipfsHash.trim() === '') {
				throw new Error('IPFS hash is required but is empty');
			}
			if (!description || description.trim() === '') {
				throw new Error('Description is required but is empty');
			}
			
			console.log('Calling contract with:', {
				projectName: projectName,
				ipfsHash: ipfsHash,
				description: description,
				contractAddress: contractAddress
			});
			
			// This will trigger MetaMask signature request
			button.innerHTML = '<i class="loading spinner icon"></i> Check MetaMask to sign transaction...';
			console.log('About to call contract.addProject with parameters:', [projectName, ipfsHash, description]);
			const tx = await contract.addProject(projectName, ipfsHash, description);
			console.log('Transaction submitted:', tx.hash);

			// Wait for transaction confirmation
			button.innerHTML = '<i class="loading spinner icon"></i> Waiting for confirmation...';
			const receipt = await tx.wait();
			console.log('Transaction confirmed:', receipt);

			// Success!
			button.innerHTML = '<i class="check icon"></i> Successfully Added to Blockchain!';
			button.style.backgroundColor = '#21ba45';
			button.disabled = true;
			
			// Log success details to console
			console.log('üéâ Successfully added repository to Arbitrum blockchain!');
			console.log('üìÅ Project:', projectName);
			console.log('üîó IPFS CID:', ipfsHash);
			console.log('‚õìÔ∏è Transaction Hash:', tx.hash);
			console.log('üì¶ Block Number:', receipt.blockNumber);
			console.log('‚õΩ Gas Used:', receipt.gasUsed.toString());
			console.log('üåê Network: Arbitrum One');
			console.log('üîç View Transaction:', `https://arbiscan.io/tx/${tx.hash}`);
			console.log('üìÇ View Files on IPFS:', `https://ipfs.io/ipfs/${ipfsHash}`);
			console.log('üìã Contract:', `https://arbiscan.io/address/0x12bba8a52ac013cfc803a5a79d4c6add112a311b`);
			
		} catch (error) {
			console.error('Error:', error);
			button.innerHTML = '<i class="exclamation triangle icon"></i> Error';
			button.style.backgroundColor = '#db2828';
			
			// Log specific error messages to console
			let errorMessage = 'Unknown error occurred';
			if (error.message) {
				errorMessage = error.message;
			} else if (error.code === 4001) {
				errorMessage = 'User rejected the request';
			} else if (error.code === -32002) {
				errorMessage = 'Request already pending. Please check MetaMask';
			}
			
			console.error('Transaction failed:', errorMessage);
			
			// Reset button after 5 seconds
			setTimeout(() => {
				button.innerHTML = originalText;
				button.disabled = false;
				button.style.backgroundColor = '';
			}, 5000);
		}
	});
});
</script>
