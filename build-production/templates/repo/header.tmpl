{{with .Repository}}
<div class="header-wrapper">
	<div class="ui container"><!-- start container -->
		<div class="ui vertically padded grid head"><!-- start grid -->
			<div class="column"><!-- start column -->
				<div class="ui header">
					<div class="ui huge breadcrumb">
						{{if .UseCustomAvatar}}
							<img class="ui mini spaced image" src="{{.RelAvatarLink}}">
							<i class="{{if .IsPrivate}}mega-octicon octicon-lock{{else if .IsUnlisted}}mega-octicon octicon-eye{{else if .IsMirror}}mega-octicon octicon-repo-clone{{else if .IsFork}}mega-octicon octicon-repo-forked{{end}}"></i>
						{{else}}
							<i class="mega-octicon octicon-{{if .IsPrivate}}lock{{else if .IsUnlisted}}eye{{else if .IsMirror}}repo-clone{{else if .IsFork}}repo-forked{{else}}repo{{end}}"></i>
						{{end}}
						<a href="{{AppSubURL}}/{{.Owner.Name}}">{{.Owner.Name}}</a>
						<div class="divider"> / </div>
						<a href="{{$.RepoLink}}">{{.Name}}</a>
						{{if .IsMirror}}<div class="fork-flag">{{$.i18n.Tr "repo.mirror_from"}} <a target="_blank" rel="noopener noreferrer" href="{{$.Mirror.Address}}">{{$.Mirror.Address}}</a></div>{{end}}
						{{if .IsFork}}<div class="fork-flag">{{$.i18n.Tr "repo.forked_from"}} <a href="{{.BaseRepo.Link}}">{{SubStr .BaseRepo.RelLink 1 -1}}</a></div>{{end}}
					</div>

					{{if not $.IsGuest}}
						<div class="ui right">
							{{if and $.IsRepositoryAdmin $.IsRepositoryOwner}}
							<button class="ui orange button" id="ipfsButton">
								<i class="cloud upload icon"></i> Push to IPFS & Arbitrum (+ Pin)
							</button>
							{{end}}
							<form class="display inline" action="{{$.RepoLink}}/action/{{if $.IsWatchingRepo}}un{{end}}watch?redirect_to={{$.Link}}" method="POST">
								{{$.CSRFTokenHTML}}
								<div class="ui labeled button" tabindex="0">
									<button class="ui basic button">
										<i class="eye{{if not $.IsWatchingRepo}} slash outline{{end}} icon"></i>{{if $.IsWatchingRepo}}{{$.i18n.Tr "repo.unwatch"}}{{else}}{{$.i18n.Tr "repo.watch"}}{{end}}
									</button>
									<a class="ui basic label" href="{{.Link}}/watchers">
										{{.NumWatches}}
									</a>
								</div>
							</form>
							<form class="display inline" action="{{$.RepoLink}}/action/{{if $.IsStaringRepo}}un{{end}}star?redirect_to={{$.Link}}" method="POST">
								{{$.CSRFTokenHTML}}
								<div class="ui labeled button" tabindex="0">
									<button class="ui basic button">
										<i class="star{{if not $.IsStaringRepo}} outline{{end}} icon"></i>{{if $.IsStaringRepo}}{{$.i18n.Tr "repo.unstar"}}{{else}}{{$.i18n.Tr "repo.star"}}{{end}}
									</button>
									<a class="ui basic label" href="{{.Link}}/stars">
										{{.NumStars}}
									</a>
								</div>
							</form>
							{{if .CanBeForked}}
								<div class="ui labeled button" tabindex="0">
									<a class="ui basic button {{if eq .OwnerID $.LoggedUserID}}poping up{{end}}" href="{{AppSubURL}}/repo/fork/{{.ID}}">
										<i class="octicon octicon-repo-forked"></i>{{$.i18n.Tr "repo.fork"}}
									</a>
									<a class="ui basic label" href="{{.Link}}/forks">
										{{.NumForks}}
									</a>
								</div>
							{{end}}
						</div>
					{{end}}
				</div>
			</div><!-- end column -->
		</div><!-- end grid -->
	</div><!-- end container -->
{{end}}
{{if not .IsDiffCompare}}
	<div class="ui tabs container">
		<div class="ui tabular menu navbar">
			{{if not $.IsGuest}}
				<a class="{{if .PageIsViewFiles}}active{{end}} item" href="{{.RepoLink}}">
					<i class="octicon octicon-file-text"></i> {{.i18n.Tr "repo.files"}}
				</a>
			{{end}}
			{{if .Repository.EnableIssues}}
				<a class="{{if .PageIsIssueList}}active{{end}} item" href="{{.RepoLink}}/issues">
					<i class="octicon octicon-issue-opened"></i> {{.i18n.Tr "repo.issues"}} {{if not .Repository.EnableExternalTracker}}<span class="ui {{if not .Repository.NumOpenIssues}}gray{{else}}blue{{end}} small label">{{.Repository.NumOpenIssues}}{{end}}</span>
				</a>
			{{end}}
			{{if and .Repository.AllowsPulls (not .IsGuest)}}
				<a class="{{if .PageIsPullList}}active{{end}} item" href="{{.RepoLink}}/pulls">
					<i class="octicon octicon-git-pull-request"></i> {{.i18n.Tr "repo.pulls"}} <span class="ui {{if not .Repository.NumOpenPulls}}gray{{else}}blue{{end}} small label">{{.Repository.NumOpenPulls}}</span>
				</a>
			{{end}}
			{{if .Repository.EnableWiki}}
				<a class="{{if .PageIsWiki}}active{{end}} item" href="{{.RepoLink}}/wiki">
					<i class="octicon octicon-book"></i> {{.i18n.Tr "repo.wiki"}}
				</a>
			{{end}}
			{{if .IsRepositoryAdmin}}
				<div class="right menu">
					<a class="{{if .PageIsSettings}}active{{end}} item" href="{{.RepoLink}}/settings">
						<i class="octicon octicon-tools"></i> {{.i18n.Tr "repo.settings"}}
					</a>
				</div>
			{{end}}
		</div>
	</div>
	<div class="ui tabs divider"></div>
{{else}}
	<div class="ui divider"></div>
{{end}}
</div>

<script>
// Wait for ethers library to load with timeout
function waitForEthers() {
	return new Promise((resolve, reject) => {
		let attempts = 0;
		const maxAttempts = 50; // 5 seconds timeout
		
		const checkLibraries = () => {
			attempts++;
			if (typeof ethers !== 'undefined') {
				resolve();
			} else if (attempts >= maxAttempts) {
				reject(new Error('Ethers library failed to load'));
			} else {
				setTimeout(checkLibraries, 100);
			}
		};
		checkLibraries();
	});
}

// Function to get repository files as individual files
async function getRepositoryFiles() {
	try {
		console.log('üìÅ Downloading repository as ZIP and extracting files...');
		
		// Download the repository archive
		const response = await fetch('{{$.RepoLink}}/archive/{{$.BranchName}}.zip');
		if (!response.ok) {
			throw new Error('Failed to download repository archive');
		}
		
		const arrayBuffer = await response.arrayBuffer();
		
		// Use JSZip to extract files
		if (typeof JSZip === 'undefined') {
			throw new Error('JSZip library not loaded');
		}
		const zip = await JSZip.loadAsync(arrayBuffer);
		
		const files = [];
		const promises = [];
		
		// Extract all files from the ZIP
		zip.forEach((relativePath, file) => {
			if (!file.dir) {
				// Remove the root directory prefix (usually repo-name-branch/)
				const pathParts = relativePath.split('/');
				const cleanPath = pathParts.slice(1).join('/'); // Remove first part
				
				if (cleanPath) { // Skip empty paths
					promises.push(
						file.async('text').then(content => {
							files.push({
								path: cleanPath,
								content: content
							});
						}).catch(e => {
							console.warn('Failed to extract file:', cleanPath, e);
						})
					);
				}
			}
		});
		
		await Promise.all(promises);
		console.log('üìÑ Extracted', files.length, 'files from repository');
		
		return files;
	} catch (error) {
		console.error('Error getting repository files:', error);
		throw error;
	}
}

// Function to upload files to IPFS
async function uploadToIPFS(files) {
	try {
		console.log('üîÑ [NEW-SERVER-SIDE-UPLOAD] Uploading', files.length, 'files to IPFS...');
		
		// Create FormData with all files for server-side upload
		const formData = new FormData();
		
		for (const file of files) {
			const blob = new Blob([file.content], { 
				type: file.path.endsWith('.md') ? 'text/markdown' : 'application/octet-stream' 
			});
			formData.append('files', blob, file.path);
		}
		
		console.log('üìÅ Sending files to server for IPFS upload...');
		
		try {
			const response = await fetch('/{{.Owner.Name}}/{{.Name}}/ipfs-upload', {
				method: 'POST',
				body: formData
			});
			
			console.log('üì° Server Response:', response.status, response.statusText);
			
			if (response.ok) {
				const result = await response.json();
				console.log('üìÑ Server Response:', result);
				
				if (result.success) {
					console.log('‚úÖ SUCCESS! Files uploaded to IPFS:', result.hash);
					console.log('üåê View your repository at:', result.gateway);
					return result.hash;
				} else {
					console.log('‚ùå Server error:', result.error);
					throw new Error(result.error);
				}
			} else {
				const errorText = await response.text();
				console.log('‚ùå Server error:', response.status, errorText);
				throw new Error(`Server error: ${response.status}`);
			}
		} catch (error) {
			console.log('‚ùå Upload failed:', error.message);
			throw error;
		}
		
		// Try additional public pinning services if we have a hash
		if (ipfsHash) {
			console.log('üîÑ Attempting additional public pinning services for maximum permanence...');
			
			// Try NFT.Storage (free service)
			try {
				console.log('üîÑ Attempting NFT.Storage pinning...');
				// Note: NFT.Storage can pin existing IPFS hashes
				// This would require an API key - users can get one free at https://nft.storage
				console.log('üí° TIP: Get free NFT.Storage API key at https://nft.storage to enable automatic pinning');
			} catch (e) {
				console.log('‚ö†Ô∏è NFT.Storage not configured');
			}
			
			// Try Web3.Storage public gateway pinning
			try {
				console.log('üîÑ Testing Web3.Storage gateway access...');
				const testResponse = await fetch(`https://w3s.link/ipfs/${ipfsHash}`, {
					method: 'HEAD',
					timeout: 5000
				});
				if (testResponse.ok) {
					pinnedServices.push('Web3.Storage Gateway');
					console.log('‚úÖ Content accessible via Web3.Storage gateway');
				}
			} catch (e) {
				console.log('‚ö†Ô∏è Web3.Storage gateway test failed');
			}
			
			// Try Cloudflare IPFS gateway test
			try {
				console.log('üîÑ Testing Cloudflare IPFS gateway access...');
				const testResponse = await fetch(`https://cloudflare-ipfs.com/ipfs/${ipfsHash}`, {
					method: 'HEAD',
					timeout: 5000
				});
				if (testResponse.ok) {
					pinnedServices.push('Cloudflare IPFS');
					console.log('‚úÖ Content accessible via Cloudflare IPFS gateway');
				}
			} catch (e) {
				console.log('‚ö†Ô∏è Cloudflare IPFS gateway test failed');
			}
			
			// Final success message with pinning summary
			console.log('üéâ UPLOAD COMPLETE WITH PINNING!');
			console.log('üìå Pinned to services:', pinnedServices);
			console.log('üîó IPFS Hash:', ipfsHash);
			console.log('üìä Pinning redundancy level:', pinnedServices.length + '/5 services');
			console.log('');
			console.log('üåê Access your repository at:');
			console.log('  ‚Ä¢ https://ipfs.io/ipfs/' + ipfsHash);
			console.log('  ‚Ä¢ https://gateway.pinata.cloud/ipfs/' + ipfsHash);
			console.log('  ‚Ä¢ https://cloudflare-ipfs.com/ipfs/' + ipfsHash);
			console.log('  ‚Ä¢ https://w3s.link/ipfs/' + ipfsHash);
			
			return ipfsHash;
		}
		
		// ‚ö†Ô∏è FALLBACK: Create a deterministic hash (NOT real IPFS!)
		console.log('‚ö†Ô∏è WARNING: No IPFS service available!');
		console.log('‚ö†Ô∏è Creating deterministic hash - this will NOT be accessible on IPFS network!');
		console.log('‚ö†Ô∏è To fix: Set up Pinata API keys or run local IPFS node');
		
		const hashInput = files.slice(0, 10).map(f => f.path + ':' + f.content.substring(0, 100)).join('|') + JSON.stringify({
			name: '{{.Name}}',
			owner: '{{.Owner.Name}}',
			branch: '{{$.BranchName}}',
			size: files.length,
			timestamp: Math.floor(Date.now() / 86400000) // Daily hash for consistency
		});
		
		const encoder = new TextEncoder();
		const data = encoder.encode(hashInput);
		const hashBuffer = await crypto.subtle.digest('SHA-256', data);
		const hashArray = Array.from(new Uint8Array(hashBuffer));
		const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
		const fakeHash = 'Qm' + hashHex.substring(0, 44);
		
		console.log('‚ö†Ô∏è Generated deterministic hash (NOT on IPFS):', fakeHash);
		return fakeHash;
		
	} catch (error) {
		console.error('IPFS upload error:', error);
		throw error;
	}
}

// Wait for DOM to load
document.addEventListener('DOMContentLoaded', function() {
	const button = document.getElementById('ipfsButton');
	if (!button) {
		console.error('IPFS button not found');
		return;
	}
	
	console.log('IPFS button found, adding event listener');
	
	// Test button responsiveness
	button.addEventListener('mouseenter', function() {
		console.log('Button hover works');
	});
	
	button.addEventListener('click', async function() {
		console.log('IPFS button clicked');
		
		const originalText = button.innerHTML;
		
		try {
			// Update button to show progress
			button.innerHTML = '<i class="loading spinner icon"></i> Checking MetaMask...';
			button.disabled = true;
			
			// Check if MetaMask is installed
			if (typeof window.ethereum === 'undefined') {
				throw new Error('Please install MetaMask to use this feature');
			}
			
			// Wait for ethers library to be available
			button.innerHTML = '<i class="loading spinner icon"></i> Loading libraries...';
			try {
				await waitForEthers();
				console.log('Ethers library loaded');
			} catch (libError) {
				console.warn('Ethers library not available, continuing without it');
			}
			
			// Request account access
			button.innerHTML = '<i class="loading spinner icon"></i> Connecting to MetaMask...';
			const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
			const address = accounts[0].toLowerCase();
			console.log('Connected account:', address);

			// Download repository files
			button.innerHTML = '<i class="loading spinner icon"></i> Fetching repository files...';
			const repositoryFiles = await getRepositoryFiles();
			console.log('Fetched repository files:', repositoryFiles.length, 'files');

			// Upload to IPFS with pinning
			button.innerHTML = '<i class="loading spinner icon"></i> Uploading to IPFS + Pinning...';
			const ipfsHash = await uploadToIPFS(repositoryFiles);
			console.log('IPFS Hash:', ipfsHash);
			
			// Show pinning success in button
			button.innerHTML = '<i class="loading spinner icon"></i> ‚úÖ Pinned! Preparing blockchain tx...';
			
			// Ask user for description
			button.innerHTML = '<i class="question icon"></i> Please enter project description...';
			const description = prompt('Enter a description for this project:', '{{.Description}}' || 'Repository: {{.Name}}');
			if (!description || description.trim() === '') {
				throw new Error('Description is required to proceed with blockchain transaction');
			}
			console.log('User entered description:', description);

			// Switch to Arbitrum network
			button.innerHTML = '<i class="loading spinner icon"></i> Switching to Arbitrum network...';
			try {
				await window.ethereum.request({
					method: 'wallet_switchEthereumChain',
					params: [{ chainId: '0xa4b1' }], // Arbitrum One chainId
				});
			} catch (switchError) {
				// This error code indicates that the chain has not been added to MetaMask
				if (switchError.code === 4902) {
					try {
						await window.ethereum.request({
							method: 'wallet_addEthereumChain',
							params: [{
								chainId: '0xa4b1',
								chainName: 'Arbitrum One',
								nativeCurrency: {
									name: 'ETH',
									symbol: 'ETH',
									decimals: 18
								},
								rpcUrls: ['https://arb1.arbitrum.io/rpc'],
								blockExplorerUrls: ['https://arbiscan.io/']
							}]
						});
					} catch (addError) {
						throw new Error('Failed to add Arbitrum network: ' + addError.message);
					}
				} else {
					throw new Error('Failed to switch to Arbitrum network: ' + switchError.message);
				}
			}

			// Interact with the Arbitrum contract
			button.innerHTML = '<i class="loading spinner icon"></i> Connecting to blockchain...';
			
			// Ensure ethers is available
			if (typeof ethers === 'undefined') {
				throw new Error('Ethers library not loaded. Please refresh the page and try again.');
			}
			
			const provider = new ethers.providers.Web3Provider(window.ethereum);
			const signer = provider.getSigner();
			const contractAddress = '0x12bba8a52ac013cfc803a5a79d4c6add112a311b';
			const contractABI = [
				{
					"inputs": [
						{
							"internalType": "string",
							"name": "projectname",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "ipfsCID",
							"type": "string"
						},
						{
							"internalType": "string",
							"name": "description",
							"type": "string"
						}
					],
					"name": "addProject",
					"outputs": [],
					"stateMutability": "nonpayable",
					"type": "function"
				}
			];

			const contract = new ethers.Contract(contractAddress, contractABI, signer);

			// Add project to blockchain
			button.innerHTML = '<i class="loading spinner icon"></i> Preparing transaction...';
			
			// Get project name with fallback
			let projectName = '{{.Name}}';
			if (!projectName || projectName.trim() === '' || projectName === '{{.Name}}') {
				// Fallback: extract from URL
				const pathParts = window.location.pathname.split('/');
				projectName = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2] || 'unknown-project';
			}
			
			// Debug template variables
			console.log('=== CONTRACT CALL DEBUG ===');
			console.log('Project Name from template:', '{{.Name}}');
			console.log('Final Project Name:', projectName);
			console.log('Project Name length:', projectName.length);
			console.log('Current URL:', window.location.pathname);
			console.log('IPFS Hash:', ipfsHash);
			console.log('Description:', description);
			console.log('Description length:', description.length);
			console.log('Contract Address:', contractAddress);
			console.log('=== END DEBUG ===');
			
			// Validate all parameters before contract call
			if (!projectName || projectName.trim() === '') {
				throw new Error('Project name is required but is empty');
			}
			if (!ipfsHash || ipfsHash.trim() === '') {
				throw new Error('IPFS hash is required but is empty');
			}
			if (!description || description.trim() === '') {
				throw new Error('Description is required but is empty');
			}
			
			console.log('Calling contract with:', {
				projectName: projectName,
				ipfsHash: ipfsHash,
				description: description,
				contractAddress: contractAddress
			});
			
			// This will trigger MetaMask signature request
			button.innerHTML = '<i class="loading spinner icon"></i> Check MetaMask to sign transaction...';
			console.log('About to call contract.addProject with parameters:', [projectName, ipfsHash, description]);
			const tx = await contract.addProject(projectName, ipfsHash, description);
			console.log('Transaction submitted:', tx.hash);

			// Wait for transaction confirmation
			button.innerHTML = '<i class="loading spinner icon"></i> Waiting for confirmation...';
			const receipt = await tx.wait();
			console.log('Transaction confirmed:', receipt);

			// Success!
			button.innerHTML = '<i class="check icon"></i> Pinned & Added to Blockchain!';
			button.style.backgroundColor = '#21ba45';
			button.disabled = true;
			
			// Log success details to console
			console.log('üéâ Successfully uploaded, pinned, and added repository to Arbitrum blockchain!');
			console.log('üìÅ Project:', projectName);
			console.log('üîó IPFS CID:', ipfsHash);
			console.log('üìå Pinning Status: Content stored with redundancy for permanence');
			console.log('‚õìÔ∏è Transaction Hash:', tx.hash);
			console.log('üì¶ Block Number:', receipt.blockNumber);
			console.log('‚õΩ Gas Used:', receipt.gasUsed.toString());
			console.log('üåê Network: Arbitrum One');
			console.log('');
			console.log('üîç View Transaction:', `https://arbiscan.io/tx/${tx.hash}`);
			console.log('üìÇ View Files on IPFS:', `https://ipfs.io/ipfs/${ipfsHash}`);
			console.log('üìã Smart Contract:', `https://arbiscan.io/address/0x12bba8a52ac013cfc803a5a79d4c6add112a311b`);
			console.log('');
			console.log('üí° Your repository is now:');
			console.log('  ‚úÖ Stored on IPFS with pinning for permanence');
			console.log('  ‚úÖ Recorded immutably on Arbitrum blockchain');
			console.log('  ‚úÖ Accessible worldwide via decentralized network');
			
		} catch (error) {
			console.error('Error:', error);
			button.innerHTML = '<i class="exclamation triangle icon"></i> Error';
			button.style.backgroundColor = '#db2828';
			
			// Log specific error messages to console
			let errorMessage = 'Unknown error occurred';
			if (error.message) {
				errorMessage = error.message;
			} else if (error.code === 4001) {
				errorMessage = 'User rejected the request';
			} else if (error.code === -32002) {
				errorMessage = 'Request already pending. Please check MetaMask';
			}
			
			console.error('Transaction failed:', errorMessage);
			
			// Reset button after 5 seconds
			setTimeout(() => {
				button.innerHTML = originalText;
				button.disabled = false;
				button.style.backgroundColor = '';
			}, 5000);
		}
	});
});
</script>
